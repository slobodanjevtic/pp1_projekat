

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected;
	Logger log = Logger.getLogger(getClass());
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, LBRACE, RBRACE, SEMI, COLON, QUEST, LPAREN, RPAREN, COMMA, LBRACKET, RBRACKET;
terminal PRINT, READ, CONST, VOID, IF, ELSE, DO, WHILE, BREAK, CONTINUE, NEW;
terminal EQUAL, RETURN, PLUS, MINUS, MUL, DIV, MOD, INC, DEC, OR, AND, EQ, NE, LT, LE, GT, GE;
terminal Integer NUMBER;
terminal Boolean BOOLVALUE;
terminal Character CHAR;
terminal String IDENT;

nonterminal VarDeclList, AllVarDeclType, VarList, MethodDeclList, SingleVarDecl, ConstVarList, SingleConstVarDecl;
nonterminal Params, StatementList, FormalParamList, FormalParamDecl, Statement;
nonterminal Addop, Mulop, Incop, Relop, Else, Do, RightParen, ActualPars, ActualParsList;
nonterminal Unmatched;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, SingleMethodDecl, MethodTypeName, Designator, SingleActualParam;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Matched, Type, Expr, Term, Factor, Const, CondExpr, CondTerm, CondFact;

Program ::= (Program) PROG ProgName:progName VarDeclList LBRACE MethodDeclList RBRACE;

ProgName ::= (ProgName) IDENT:progName;

VarDeclList ::= (VarDecl) VarDeclList AllVarDeclType
			| 
			(NoVarDecl) /* epsilon */
			;
			
AllVarDeclType ::= (VarDeclType) Type:varType VarList:list SEMI
			|
			(ConstVarDeclType) Type:varType ConstVarList:list SEMI
			;

VarList ::= (MultipleVarList) VarList:list COMMA SingleVarDecl:var
		|
		(SingleVarList) SingleVarDecl:var
		;
			
SingleVarDecl ::= (SingleOneVarDecl)  IDENT:varName
				|
				(SingleArrVarDecl)  IDENT:varName LBRACKET RBRACKET
				;
				
ConstVarList ::= (MultipleConstVarList) ConstVarList:list COMMA SingleConstVarDecl:var
				|
				(SingleConstVarList) SingleConstVarDecl:var
				;
				
SingleConstVarDecl ::= (SingleConstVarDecl) IDENT:varName EQUAL Const;

Type ::= (Type) IDENT:typeName;

MethodDeclList ::= (MethodDecl) MethodDeclList SingleMethodDecl
				|
				(NoMethodDecl)/* epsilon */
				;
				
SingleMethodDecl ::= (SingleMethodDecl) MethodTypeName LPAREN Params RPAREN VarDeclList LBRACE StatementList RBRACE;

MethodTypeName ::= (MethodTypeName) Type:retTypeName IDENT:methName;

Params ::= (FormParams) FormalParamList
			|
			(NoFormParam) /* epsilon */
			;
			
FormalParamList ::= (MultipleFormalParamDecl) FormalParamList COMMA FormalParamDecl
				|
				(SingleFormalParamDecl) FormalParamDecl
				;
				
FormalParamDecl ::= (FormalParamDecl) Type IDENT:paramName;

StatementList ::= (Statements) StatementList Statement
				|
				(NoStmt) /* epsilon */
				;
				
Statement ::= (MatchedStmt) Matched
			|
			(UnmatchedStmt) Unmatched
			;
		
Unmatched ::= (UnmatchedIf) IF LPAREN CondExpr RightParen Statement
			|
			(UnmatchedIfElse) IF LPAREN CondExpr RightParen Matched Else Unmatched
			;
			
			
RightParen ::= (RightParen) RPAREN; 

Else ::= (Else) ELSE;

Do ::= (Do) DO;  
				
Matched ::= (Block) LBRACE StatementList RBRACE
			|
			(Assignment) Designator:dest EQUAL Expr:ex SEMI
			|
			(Increment) Designator:de Incop SEMI
			|
			(ErrorStmt) error SEMI:sm
			{: parser.report_error("Izvrsen oporavak do ; u liniji " + smleft, null); :}
			|
			(PrintStmt) PRINT LPAREN Expr RPAREN SEMI
			|
			(PrintStmtNum) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
			|
			(ReadStmt) READ LPAREN Designator RPAREN SEMI
			|
			(ReturnExpr) RETURN Expr:t SEMI
			|
			(BreakExpr) BREAK SEMI
			|
			(ContinueExpr) CONTINUE SEMI
			|
			(ReturnNoExpr) RETURN SEMI
			|
			(MatchedIfElse) IF LPAREN CondExpr RightParen Matched Else Matched
			|
			(MatchedDoWhile) Do Matched WHILE LPAREN CondExpr RightParen SEMI
			|
			(ProcCall) Designator:func LPAREN ActualPars RPAREN SEMI
			;
			
Expr ::= (AddExpr) Expr:ex Addop Term:tr
		|
		(MinusTermExpr) MINUS Term:tr
		|
		(TermExpr) Term:tr
		;
		
Term ::= (MulExpr) Term:tr Mulop Factor:fc
		| 
		(Fact) Factor:fc
		;
		
Factor ::= (TypeConst) Const
		|
		(Var) Designator:d
		|
		(FuncCall) Designator:func LPAREN ActualPars RPAREN
		|
		(ParenExpr) LPAREN Expr:ex RPAREN
		|
		(ArrExpr) NEW Type LBRACKET Expr:ex RBRACKET
		;
		
Const ::= (NumConst) NUMBER
		|
		(BoolConst) BOOLVALUE
		|
		(CharConst) CHAR
		;
		
CondExpr ::= (OrCondExpr) CondExpr:ce OR CondTerm:ct
			|
			(SingleOrCondExpr) CondTerm:ct
			;
			
CondTerm ::= (AndCondExpr) CondTerm:ct AND CondFact:cf
			|
			(SingleAndCondExpr) CondFact:cf
			;
			
CondFact ::= (RelCondFact) Expr:ex1 Relop Expr:ex2
			|
			(SingleRelCondFact) Expr:ex
			;
		
ActualPars ::= (Actuals) ActualParsList
			|
			(NoActuals) /* epsilon */
			;
			
ActualParsList ::= (ActualParams) ActualParsList COMMA SingleActualParam
				|
				(ActualParam) SingleActualParam
				;
				
SingleActualParam ::= (SingleActualParam) Expr:ex;
			
Designator ::= (SingleDesignator) IDENT:name
			|
			(ArrayDesignator) IDENT:name LBRACKET Expr:ex RBRACKET
			;

Addop ::= (Add) PLUS
		|
		(Sub) MINUS
		;
		
Mulop ::= (Mul) MUL
		|
		(Div) DIV
		|
		(Mod) MOD
		;
		
Incop ::= (Inc) INC
		|
		(Dec) DEC
		;
		
Relop ::= (Eq) EQ
		| 
		(Ne) NE
		|
		(Lt) LT
		|
		(Le) LE
		|
		(Gt) GT
		|
		(Ge) GE
		;
			