

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected;
	Logger log = Logger.getLogger(getClass());
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, EQUAL, RETURN, PLUS, MINUS, MUL, DIV, MOD, INC, DEC, PRINT, READ, VOID;
terminal Integer NUMBER;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String IDENT;
terminal IF, ELSE;

nonterminal VarDeclList, MethodDeclList, SingleVarDecl;
nonterminal Params, StatementList, FormalParamList, FormalParamDecl, Statement;
nonterminal Addop, Mulop, Incop, ActualPars, ActualParsList;
nonterminal Matched, Unmatched;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, SingleMethodDecl, MethodTypeName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Expr, Term, Factor;

Program ::= (Program) PROG ProgName:progName VarDeclList LBRACE MethodDeclList RBRACE;

ProgName ::= (ProgName) IDENT:progName;

VarDeclList ::= (VarDecl) VarDeclList SingleVarDecl
			| 
			(NoVarDecl) /* epsilon */
			;
			
SingleVarDecl ::= (SingleVarDecl) Type:varType IDENT:varName SEMI;

Type ::= (Type) IDENT:typeName;

MethodDeclList ::= (MethodDecl) MethodDeclList SingleMethodDecl
				|
				(NoMethodDecl)/* epsilon */
				;
				
SingleMethodDecl ::= (SingleMethodDecl) MethodTypeName LPAREN Params RPAREN VarDeclList LBRACE StatementList RBRACE;

MethodTypeName ::= (MethodTypeName) Type:retTypeName IDENT:methName;

Params ::= (FormParams) FormalParamList
			|
			(NoFormParam) /* epsilon */
			;
			
FormalParamList ::= (MultipleFormalParamDecl) FormalParamList COMMA FormalParamDecl
				|
				(SingleFormalParamDecl) FormalParamDecl
				;
				
FormalParamDecl ::= (FormalParamDecl) Type IDENT:paramName;
				
StatementList ::= (Statements) StatementList Statement
				|
				(NoStmt) /* epsilon */
				;
				
Statement ::= (MatchedStmt) Matched
			|
			(UnmatchedStmt) Unmatched
			;
		
Unmatched ::= (UnmatchedIf) IF Expr Statement
			|
			(UnmatchedElse) IF Expr Matched ELSE Unmatched
			;
				
Matched ::= (Assignment) Designator:dest EQUAL Expr:ex SEMI
			|
			(Increment) Designator:de Incop SEMI
			|
			(ErrorStmt) error SEMI:sm
			{: parser.report_error("Izvrsen oporavak do ; u liniji " + smleft, null); :}
			|
			(PrintStmt) PRINT LPAREN Expr RPAREN SEMI
			|
			(ReturnExpr) RETURN Expr:t SEMI
			|
			(ReturnNoExpr) RETURN SEMI
			|
			(MatchedStatement) IF Expr Matched ELSE Matched
			|
			(ProcCall) Designator:func LPAREN ActualPars RPAREN SEMI
			;
			
Expr ::= (AddExpr) Expr:ex Addop Term:tr
		|
		(TermExpr) Term:tr
		;
		
Term ::= (MulExpr) Term:tr Mulop Factor:fc
		| 
		(Fact) Factor:fc;
		

Factor ::= (NumConst) NUMBER
		|
		(BoolConst) BOOL
		|
		(CharConst) CHAR
		|
		(Var) Designator:d
		|
		(FuncCall) Designator:func LPAREN ActualPars RPAREN
		;
		
ActualPars ::= (Actuals) ActualParsList
			|
			(NoActuals) /* epsilon */
			;
			
ActualParsList ::= (ActualParams) ActualParsList COMMA Expr
				|
				(ActualParam) Expr
				;
				
Designator ::= (Designator) IDENT:name;

Addop ::= (Add) PLUS
		|
		(Sub) MINUS
		;
		
Mulop ::= (Mul) MUL
		|
		(Div) DIV
		|
		(Mod) MOD
		;
		
Incop ::= (Inc) INC
		|
		(Dec) DEC
		;
			